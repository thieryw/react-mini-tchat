{"version":3,"sources":["components/User/Contacts.tsx","components/User/Conversation.tsx","components/User/User.tsx","components/App/App.tsx","logic.ts","index.tsx"],"names":["Contacts","props","user","store","isComponentVisible","useReducer","x","forceUpdate","asyncNewConversation","useAsyncCallback","newConversation","asyncEmptyInterlocutor","emptyInterlocutors","asyncSelectInterlocutor","selectInterlocutor","asyncUnselectInterlocutor","unselectInterlocutor","useEvt","ctx","Evt","merge","evtInterlocutorSelected","evtInterlocutorUnselected","attach","data","same","backToConversation","useCallback","execute","className","style","height","loading","type","value","color","disabled","onClick","interlocutors","map","interlocutor","name","contacts","length","contact","index","key","Contact","useState","isSelected","setIsSelected","handleClick","evtConversationStarted","evtInterlocutorsEmptied","_user","Conversation","textInput","setTextInput","numberOfMessagesToDisplay","setNumberOfMessagesToDisplay","messagesRef","useRef","asyncSendMessage","sendMessage","asyncUnselectConversation","unselectConversation","handleSubmit","evtMessageSent","emitter","currentConversation","participants","scrollToBottom","evtConversationSelected","current","scrollTo","scrollHeight","handleScroll","undefined","scrollTop","messages","participant","onScroll","ref","message","onChange","target","Message","messageRef","adjustWidth","a","Promise","resolve","setTimeout","width","useEffect","description","User","isUserVisible","isContactVisible","setIsContactVisible","isConversationVisible","setIsConversationVisible","evtConversationUnselected","selectConversation","conversation","conversationsStyle","display","conversations","App","userIndex","setUserIndex","window","changeUser","users","getStore","simulateNetworkDelay","ms","out","i","push","forEach","_index","params","post","splice","indexOf","Error","console","log","conversationId","Switcher","asyncGetStore","useAsync","result","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.5c3c1707.chunk.js","sourcesContent":["import React, {useCallback, useState, useReducer} from \"react\";\nimport {Store} from \"../../logic\";\nimport {useAsyncCallback, UseAsyncReturn} from \"react-async-hook\";\nimport {useEvt} from \"evt/hooks\";\nimport {same} from \"evt/tools/inDepth\";\nimport {Evt} from \"evt\";\nimport \"./Contacts.scss\";\n\n\n\n\nexport const Contacts: React.FunctionComponent<{\n    user: Store[\"users\"][number];\n    store: Pick<Store,\n        \"evtInterlocutorSelected\" |\n        \"newConversation\" |\n        \"selectInterlocutor\" |\n        \"unselectInterlocutor\" |\n        \"evtInterlocutorUnselected\" |\n        \"emptyInterlocutors\" |\n        \"evtInterlocutorsEmptied\" |\n        \"evtConversationStarted\"\n\n    >;\n\n    isComponentVisible: boolean;\n\n}> = (props)=>{\n\n\n    const {user, store, isComponentVisible} = props;\n    const [, forceUpdate] = useReducer(x=>x+1, 0);\n    \n\n\n    const asyncNewConversation = useAsyncCallback(store.newConversation);\n    const asyncEmptyInterlocutor = useAsyncCallback(store.emptyInterlocutors);\n    const asyncSelectInterlocutor = useAsyncCallback(store.selectInterlocutor);\n    const asyncUnselectInterlocutor = useAsyncCallback(store.unselectInterlocutor);\n    useEvt(ctx =>{\n\n        Evt.merge(ctx, [store.evtInterlocutorSelected, store.evtInterlocutorUnselected]).attach(\n            data => same(user, data.user),\n            ()=> forceUpdate()\n        );\n\n        \n        \n\n    }, [store, user]);\n\n\n\n\n    const backToConversation = useCallback(()=>{\n        \n        asyncEmptyInterlocutor.execute(user);\n\n    },[asyncEmptyInterlocutor, user])\n\n    \n\n\n\n    return(\n        <div \n            className=\"contacts\"\n            style={\n                {\n                    height: isComponentVisible && \n                    !asyncEmptyInterlocutor.loading &&\n                    !asyncNewConversation.loading ?\n                    \"100%\" : \"0%\",\n                }\n            }\n        >\n            <header>\n                <input \n                    type=\"button\" \n                    value=\"<\"\n                    style={\n                        {color: asyncEmptyInterlocutor.loading\n                            || \n                        asyncNewConversation.loading ? \"grey\" : \"greenyellow\"}\n                    }\n                    disabled={asyncEmptyInterlocutor.loading}\n                    onClick={backToConversation}\n                />\n                <div>\n                    <h2>Contacts</h2>\n                    {\n                        asyncSelectInterlocutor.loading ||\n                        asyncUnselectInterlocutor.loading ?\n                        <em className=\"loading\">Loading...</em> : \n                        <em>{user.interlocutors.map(interlocutor => `${interlocutor.name}, `)}</em>\n                    }\n                    \n\n                </div>\n\n\n            </header>\n            <em>{user.contacts.length} contacts</em>\n\n            <section>\n                {\n                    user.contacts.map(\n                        (contact, index)=> \n                                <Contact \n                                    store={store} \n                                    contact={contact} \n                                    user={user}\n                                    asyncSelectInterlocutor={asyncSelectInterlocutor}\n                                    asyncUnselectInterlocutor={asyncUnselectInterlocutor}\n                                    key={index}\n                                />\n\n                    )\n                    \n                }\n            </section>\n\n\n\n            <input \n                disabled={user.interlocutors.length === 0} \n                className={user.interlocutors.length === 0 ? \"disabled\" : \"\"}\n                type=\"button\" \n                value=\">\"\n                onClick={\n                    useCallback(()=>\n                        asyncNewConversation.execute(user)\n                    , [user, asyncNewConversation])\n\n                }\n            />\n\n\n\n\n\n        </div>\n    )\n}\n\nconst Contact: React.FunctionComponent<{\n    contact: Store[\"users\"][number][\"contacts\"][number];\n    user: Store[\"users\"][number];\n    store: Pick<Store,\n        \"selectInterlocutor\" |\n        \"evtInterlocutorSelected\"|\n        \"unselectInterlocutor\" |\n        \"evtInterlocutorUnselected\" |\n        \"evtInterlocutorsEmptied\" |\n        \"evtConversationStarted\"\n\n    >\n\n    asyncSelectInterlocutor: UseAsyncReturn<void, [{\n        user: Store[\"users\"][number];\n        contact: Store[\"users\"][number];\n    }]>\n\n    asyncUnselectInterlocutor: UseAsyncReturn<void, [{\n        user: Store[\"users\"][number];\n        contact: Store[\"users\"][number];\n    }]>\n\n}> = (props)=>{\n\n    const {\n        contact, \n        user, \n        store, \n        asyncSelectInterlocutor, \n        asyncUnselectInterlocutor\n    } = props;\n\n    const [isSelected, setIsSelected] = useState(false);\n\n    const handleClick = useCallback(()=>{\n        if(isSelected){\n            asyncUnselectInterlocutor.execute({user, contact});\n            return;\n        }\n\n        asyncSelectInterlocutor.execute({user, contact});\n\n    }, [isSelected, contact, user, asyncUnselectInterlocutor, asyncSelectInterlocutor]);\n\n    useEvt(ctx=>{\n\n        Evt.merge(ctx, [store.evtInterlocutorSelected, store.evtInterlocutorUnselected]).attach(\n            data => same(user, data.user) && same(contact, data.contact),\n            ()=> setIsSelected(!isSelected)\n        );\n\n\n        Evt.merge(ctx, [store.evtConversationStarted, store.evtInterlocutorsEmptied]).attach(\n            _user => same(user, _user) && isSelected,\n            () => setIsSelected(false)\n        );\n\n\n\n\n    },[contact, user, store, isSelected])\n\n    return(\n        <div className={`contact ${isSelected ? \"contact-selected\" : \"\"}`} onClick={handleClick}>\n\n            <p>{contact.name}</p>\n\n\n        </div>\n\n    )\n\n}","import React, {useState, useCallback, useReducer, useRef, useEffect} from \"react\";\nimport {Store} from \"../../logic\";\nimport {useAsyncCallback} from \"react-async-hook\";\nimport {useEvt} from \"evt/hooks\";\nimport {same} from \"evt/tools/inDepth\";\nimport \"./Conversation.scss\";\n\n\nexport const Conversation: React.FunctionComponent<{\n    store: Pick<Store,\n        \"sendMessage\" |\n        \"evtMessageSent\" |\n        \"evtConversationSelected\" |\n        \"unselectConversation\" |\n        \"evtConversationUnselected\"\n    >;\n    user: Store[\"users\"][number];\n    isComponentVisible: boolean;\n    \n}> = (props)=>{\n    const {user, isComponentVisible, store} = props;\n    const [textInput, setTextInput] = useState(\"\");\n    const [numberOfMessagesToDisplay, setNumberOfMessagesToDisplay] = useState(10);\n\n   \n    const [, forceUpdate] = useReducer(x=>x+1, 0);\n    const messagesRef = useRef<HTMLDivElement>(null);\n\n    const asyncSendMessage = useAsyncCallback(store.sendMessage);\n    const asyncUnselectConversation = useAsyncCallback(store.unselectConversation);\n\n\n\n\n    const handleSubmit = useCallback(()=>{\n\n        asyncSendMessage.execute({\n            \"description\": textInput,\n            \"emitter\": user\n        });\n\n\n        \n\n        setTextInput(\"\");\n\n\n\n    },[textInput, asyncSendMessage, user]);\n\n    useEvt(ctx =>{\n        store.evtMessageSent.attach(\n            data => same(\n                data.emitter.currentConversation?.participants,\n                user.currentConversation?.participants\n            ),\n            ctx,\n            ()=> {\n               forceUpdate(); \n               scrollToBottom();\n            }\n        );\n\n\n        store.evtConversationSelected.attach(\n            data => same(data.user, user),\n            ctx,\n            ()=> {\n                forceUpdate();\n                setNumberOfMessagesToDisplay(10);\n                scrollToBottom();\n            }\n        );\n        \n\n    },[store, user]);\n\n\n    const scrollToBottom = useCallback(()=>{\n        if(!messagesRef || !messagesRef.current){\n            return;\n        }\n\n        messagesRef.current.scrollTo(0, messagesRef.current.scrollHeight);\n\n    },[])\n\n    \n    const handleScroll = useCallback(()=>{\n\n\n\n        if(!messagesRef || !messagesRef.current){\n            return;\n        }\n\n        if(\n            user.currentConversation === undefined || \n            messagesRef.current.scrollTop !== 0 || \n            user.currentConversation.messages.length === numberOfMessagesToDisplay\n        ){\n            return;\n        }\n\n\n        if(numberOfMessagesToDisplay + 10 > user.currentConversation.messages.length){\n            setNumberOfMessagesToDisplay(user.currentConversation.messages.length);\n            return;\n        }\n\n        setNumberOfMessagesToDisplay(numberOfMessagesToDisplay + 10);\n\n\n    },[numberOfMessagesToDisplay, user.currentConversation]);\n\n    \n\n    \n\n\n\n    return(\n\n        <div \n            className=\"Conversation\"\n            style={\n                {\n                    height: isComponentVisible \n                    && !asyncUnselectConversation.loading ? \"100%\" : \"0%\"\n                }\n            }\n        >\n            <header>\n                <h3>\n                    {\n                        user.currentConversation?.participants.map(\n                            participant => `${participant.name}, `\n                        )\n                    }\n                </h3>\n                <input \n                    type=\"button\"\n                    value=\"<\"\n                    onClick={\n                        useCallback(()=>{\n\n                            asyncUnselectConversation.execute(user);\n\n                        }, [user, asyncUnselectConversation])\n                    }\n                />\n            </header>\n\n\n            <div onScroll={handleScroll} ref={messagesRef} className=\"messages\">\n\n                {\n                    user.currentConversation?.messages.map(\n                        (message, index) => \n                            user.currentConversation === undefined ? \"\" : \n                            index < user.currentConversation.messages.length - numberOfMessagesToDisplay ? \"\" :\n                            <Message \n                                key={index} \n                                message={message}\n                                user={user}\n                                \n                            />\n                         \n\n                    )\n                }\n            </div>\n\n            <form>\n                <textarea \n                    onChange={useCallback(({target}) => setTextInput(target.value), [])} \n                    value={textInput}\n                />\n\n                <input \n                    type=\"submit\" \n                    value={asyncSendMessage.loading ? \"...\" : \">\"}\n                    disabled={asyncSendMessage.loading}\n                    onClick={handleSubmit}\n                />\n\n            </form>\n                \n\n\n\n\n        </div>\n\n    )\n}\n\nconst Message: React.FunctionComponent<{\n    message: Store[\"users\"][number][\"conversations\"][number][\"messages\"][number];\n    user: Store[\"users\"][number];\n\n}> = (props)=>{\n\n    const {message, user} = props\n\n    const messageRef = useRef<HTMLDivElement>(null);\n\n\n\n    const adjustWidth = useCallback(async ()=>{\n\n        await new Promise<void>(resolve => setTimeout(resolve, 1));\n\n        if(!messageRef || !messageRef.current){\n                return;\n        }\n\n        messageRef.current.style.width = \"100%\";\n\n    },[messageRef]);\n\n    useEffect(()=>{\n\n        adjustWidth();\n\n\n    },[adjustWidth]);\n\n\n\n\n\n\n\n\n\n\n    return(\n        <div \n            ref={messageRef}\n            className={message.emitter === user ? \"outgoing\" : \"incoming\"}\n            style={\n                {\n                    width: \"50%\"\n\n                }\n            }\n        >\n            <div>\n                <em>{message.emitter.name}</em>\n                <p>{\n                    message.description\n                }</p>\n            </div>\n\n        </div>\n    )\n}","import React, {useState, useCallback} from \"react\";\nimport {Store} from \"../../logic\";\nimport {useEvt} from \"evt/hooks\";\nimport {same} from \"evt/tools/inDepth\";\nimport {Contacts} from \"./Contacts\";\nimport {Conversation} from \"./Conversation\";\nimport {Evt} from \"evt\";\nimport \"./User.scss\";\n\n\n\n\nexport const User: React.FunctionComponent<{\n    user: Store[\"users\"][number];\n    isUserVisible: boolean;\n    store: Omit<Store,\n        \"users\"\n    >;\n}> = (props)=>{\n\n    const {user, store, isUserVisible} = props;\n    const [isContactVisible, setIsContactVisible] = useState(false);\n    const [isConversationVisible, setIsConversationVisible] = useState(false);\n\n    useEvt(ctx=>{\n        \n\n        Evt.merge(ctx, [store.evtConversationStarted, store.evtInterlocutorsEmptied]).attach(\n            _user => same(_user, user),\n            () => setIsContactVisible(false)\n        );\n\n        \n\n        store.evtConversationUnselected.attach(\n            _user => same(user, _user),\n            ctx,\n            () => setIsConversationVisible(false)\n        );\n\n        store.evtConversationSelected.attach(\n            data => same(data.user, user),\n            ctx,\n            () => setIsConversationVisible(true)\n        );\n\n\n\n    },[store, user]);\n\n\n    const selectConversation = useCallback((conversation: Store[\"users\"][number][\"conversations\"][number])=>{\n\n\n\n        store.selectConversation({\n            conversation,\n            user\n        });\n\n\n\n\n    },[store, user])\n\n    const conversationsStyle = {\n        display: isContactVisible || isConversationVisible ? \"none\" : \"flex\"\n\n    }\n\n\n\n    return(\n        <div className={isUserVisible ? \"User\" : \"hidden\"}>\n            <div className=\"conversation-wrapper\" style={conversationsStyle}>\n                <header>\n                    <div>\n                        <h2>{user.name}</h2>\n                    </div>\n\n\n                    <input type=\"button\" value=\"+\" onClick={useCallback(()=> setIsContactVisible(true), [])}/>\n\n                </header>\n\n                <div className=\"conversations\">\n\n                    {\n                        user.conversations.length === 0 ? \"\" : \n                        user.conversations.map((conversation, index) => \n                            <div \n                                className=\"conversation-li\"\n                                key={index}\n                                onClick={()=> selectConversation(conversation)}\n                            >\n                            {\n                                <p>\n                                    {\n                                        conversation.participants.map(participant => `${participant.name}, `)\n                                    }\n                                </p>\n                            }\n                            </div>\n                        )\n                    }\n\n\n                </div>\n            </div>\n\n            <Contacts store={store} user={user} isComponentVisible={isContactVisible}/>\n\n\n            <Conversation \n                isComponentVisible={isConversationVisible}\n                store={store}\n                user={user}\n            />\n\n\n\n\n\n\n\n        </div>\n    )\n}","import React, {useState} from \"react\";\nimport {Store} from \"../../logic\";\nimport {User} from \"../User/User\";\nimport \"./App.scss\";\n\n\n\nexport const App: React.FunctionComponent<{store: Store}> = (props)=>{\n\n    const {store} = props;\n    const [userIndex, setUserIndex] = useState(0);\n\n\n\n    (window as any).changeUser = function(index: number){\n        if(index >= store.users.length || index < 0){\n            return;\n        }\n\n        setUserIndex(index);\n    }\n  \n\n    \n\n\n    return(\n        <div className=\"App\">\n\n            {\n                store.users.map(\n                    (user, index) => <User user={user} isUserVisible={userIndex === index} store={store} key={index}/>\n                )\n            }\n\n\n        </div>\n    )\n}","import {Evt, NonPostableEvt, ToPostableEvt} from \"evt\";\n\n\ntype Message = {\n    description: string;\n    emitter: User;\n    receivers: User[];\n}\n\ntype Conversation = {\n    participants: User[];\n    messages: Message[];\n    id: number;\n}\ntype User = {\n    name: string;\n    contacts: User[];\n    interlocutors: User[];\n    conversations: Conversation[];\n    currentConversation: Conversation | undefined;\n    id: number;\n\n}\n\nexport type Store = {\n    users: User[];\n    selectInterlocutor: (params: {user: User; contact: User}) => Promise<void>;\n    unselectInterlocutor: (params: {user: User; contact: User}) => Promise<void>;\n    emptyInterlocutors: (user: User) => Promise<void>;\n    selectConversation: (params: {user: User; conversation: Conversation})=> Promise<void>;\n    unselectConversation: (user: User)=> Promise<void>;\n    sendMessage: (params: {emitter: User; description: string}) => Promise<void>;\n    newConversation: (user: User)=> Promise<void>;\n\n    evtInterlocutorSelected: NonPostableEvt<Parameters<Store[\"selectInterlocutor\"]>[0]>;\n    evtInterlocutorUnselected: NonPostableEvt<Parameters<Store[\"unselectInterlocutor\"]>[0]>;\n    evtInterlocutorsEmptied: NonPostableEvt<User>;\n    evtMessageSent: NonPostableEvt<Parameters<Store[\"sendMessage\"]>[0]>;\n    evtConversationSelected: NonPostableEvt<Parameters<Store[\"selectConversation\"]>[0]>;\n    evtConversationUnselected: NonPostableEvt<User>;\n    evtConversationStarted: NonPostableEvt<Parameters<Store[\"newConversation\"]>[0]>;\n}\n\n\nexport async function getStore(): Promise<Store>{\n\n    const simulateNetworkDelay = (ms: number)=>{\n        return new Promise<void>(resolve => setTimeout(resolve, ms));\n    }\n\n    const users: User[] = (()=>{\n        const out: User[] = [];\n        for(let i = 0; i < 30; i++){\n            out.push({\n                \"contacts\": [],\n                \"name\": `User ${i+1}`,\n                \"interlocutors\": [],\n                \"conversations\": [],\n                \"currentConversation\": undefined,\n                \"id\": i\n            })\n        }\n\n        out.forEach((user, index)=>{\n            out.forEach((_user, _index)=>{\n                if(index === _index){\n                    return;\n                }\n\n                user.contacts.push(_user);\n            });\n        });\n\n\n        return out;\n\n    })();\n\n    let conversationId: 0;\n\n\n    const store: ToPostableEvt<Store> = {\n       users,\n       \"evtInterlocutorSelected\": new Evt(),\n       \"evtInterlocutorUnselected\": new Evt(),\n       \"evtInterlocutorsEmptied\": new Evt(),\n       \"evtMessageSent\": new Evt(),\n       \"evtConversationStarted\": new Evt(),\n       \"evtConversationSelected\": new Evt(),\n       \"evtConversationUnselected\": new Evt(),\n\n       \"selectInterlocutor\": async params =>{\n           const {contact, user} = params;\n\n           await simulateNetworkDelay(300);\n\n           user.interlocutors.push(contact);\n\n           store.evtInterlocutorSelected.post(params);\n\n       },\n\n       \"unselectInterlocutor\": async params =>{\n           const {contact, user} = params;\n\n           await simulateNetworkDelay(300);\n\n\n           user.interlocutors.splice(\n               user.interlocutors.indexOf(contact),\n               1\n           );\n\n           store.evtInterlocutorUnselected.post(params);\n\n       },\n\n       \"emptyInterlocutors\": async user =>{\n           await simulateNetworkDelay(300);\n\n           user.interlocutors = [];\n\n           store.evtInterlocutorsEmptied.post(user);\n       },\n\n       \"selectConversation\": async params =>{\n           const {conversation, user} = params;\n\n           await simulateNetworkDelay(300);\n\n           user.currentConversation = conversation;\n\n           store.evtConversationSelected.post(params);\n\n       },\n\n       \"unselectConversation\": async user =>{\n\n           await simulateNetworkDelay(300);\n\n           user.currentConversation = undefined;\n\n           store.evtConversationUnselected.post(user);\n\n       },\n\n       \"newConversation\": async user =>{\n           await simulateNetworkDelay(300);\n\n           try{\n               if(user.interlocutors.length === 0){\n                   throw new Error(\"Error! No interlocutors selected\");\n               }\n\n           }catch(err){\n                console.log(err);\n                return;\n           }\n\n           const newConversation: Conversation = {\n               \"id\": conversationId++,\n               \"messages\": [],\n               \"participants\": (()=>{\n                   const out: User[] = [];\n\n                   out.push(user);\n\n                   user.interlocutors.forEach(user =>{\n                       out.push(user);\n                   });\n\n                   return out;\n               })()\n\n           }\n\n           user.conversations.push(newConversation);\n\n           user.interlocutors.forEach(interlocutor => interlocutor.conversations.push(newConversation));\n\n           user.interlocutors = [];\n\n           store.evtConversationStarted.post(user);\n       },\n\n       \"sendMessage\": async params =>{\n           const {emitter, description} = params;\n\n           await simulateNetworkDelay(300);\n\n           emitter.currentConversation?.messages.push({\n               description,\n               emitter,\n               \"receivers\": (()=>{\n\n                   const out: User[] = [];\n\n                   emitter.currentConversation.participants.forEach(participant =>{\n                       if(participant === emitter){\n                           return;\n                       }\n\n                       out.push(participant);\n                   })\n\n                   return out;\n               })()\n           });\n\n\n           store.evtMessageSent.post(params);\n\n\n       }\n\n    }\n\n\n    await simulateNetworkDelay(1500);\n\n\n    return store;\n\n\n\n}\n\n\n\n\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\n//import * as serviceWorker from './serviceWorker';\nimport {App} from \"./components/App/App\";\nimport {useAsync} from \"react-async-hook\";\nimport {getStore} from \"./logic\";\n\nconst Switcher: React.FunctionComponent = ()=>{\n  \n  const asyncGetStore = useAsync(getStore, []);\n  \n  \n  return(\n    asyncGetStore.result === undefined ? \n      <h1>Loading...</h1> : \n      <App store={asyncGetStore.result} \n    />\n\n  )\n}\n\nReactDOM.render(\n  <React.StrictMode>\n    <Switcher />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n//serviceWorker.unregister();\n"],"sourceRoot":""}